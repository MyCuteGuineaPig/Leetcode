class Solution {
public:
    void bfs(vector<vector<int>>& graph, unordered_set<int>initial_set, int init, vector<vector<int>>&dp){
        queue<int>q; q.push(init);
        int n = graph.size();
        while(!q.empty())
        {
            int cur = q.front(); q.pop();
            for(int i = 0; i < n; ++i){
                if(graph[cur][i] == 0 || initial_set.count(i)) continue;
                initial_set.insert(i);
                q.push(i);
                dp[i].push_back(init);
            }
        }
    }

    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        unordered_set<int>initial_set(initial.begin(), initial.end());
        int n = graph.size();
        vector<vector<int>>dp(n,vector<int>());
        for(auto init: initial){
            bfs(graph, initial_set, init,dp);
        }
        vector<int>init_cnt(n);
        for(int i = 0; i < n; ++i){
            if (dp[i].size() == 1)
                ++init_cnt[dp[i][0]];
        }
        if (*max_element(init_cnt.begin(), init_cnt.end()) == 0){
            return *min_element(initial.begin(), initial.end());
        }
        int res = -1;
        int max_cnt = 0;
        for(int i = 0 ; i < n; ++i){
            if(init_cnt[i] > max_cnt){
                max_cnt = init_cnt[i];
                res = i;
            }
        }
        return res;
    }
};


class Solution {
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        vector<int> roots(n);
        for (auto i = 0; i < n; i++) roots[i] = i;
        
        auto find = [&](int id) {
            while (roots[id] != id) {
                roots[id] = roots[roots[id]];
                id = roots[id];
            }
            return id;
        };
        
        // Consider non-malware nodes
        vector<int> clean;
        set<int> initial_set(initial.begin(), initial.end());
        for (auto i = 0; i < n; i++)
            if (!initial_set.count(i)) clean.push_back(i);
        
        // Union Find on non-malware nodes
        for (auto i : clean)
            for (auto j : clean)
                if (i != j && graph[i][j])
                    roots[find(i)] = find(j);
        
        // Size of each group
        vector<int> area(n, 0);
        for (auto i : clean) area[find(i)]++;
        
        map<int, set<int>> infect_node; // malware -> nodes infected
        map<int, int> infect_count; // node -> # of infecting malware
        for (auto i : initial) {
            for (auto j : clean) {
                if (graph[i][j]) infect_node[i].insert(find(j));
            }
            for (auto j : infect_node[i])
                infect_count[j] += 1;
        }
        
        // Try remove each malware
        int res = initial[0], max_cnt = -1;
        for (auto& [malware, nodes] : infect_node) {
            int count = 0;
            for (auto& node : nodes) {
                // Only effective when node is infected by one malware

                /*
                The final step. We try to remove each malware (and all the groups it's connecting). 
                If the group has exactly one malware source, then removing this malware
                should "save" this group of nodes from malware. 
                Otherwise, if the group has multiple malware sources, 
                removing this malware doesn't help because the nodes will eventually infected by another malware.
                */
                if (infect_count[node] == 1)
                    count += area[node];
            }
            if (count > max_cnt || (count >= max_cnt && malware < res)) {
                max_cnt = count;
                res = malware;
            }
        }
        
        return res;
    }
};