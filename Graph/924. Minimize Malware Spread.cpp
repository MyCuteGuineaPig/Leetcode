class Solution {
public:
    int find(vector<int>&parent, int cur){
        return parent[cur] == cur ? cur : parent[cur] = find(parent, parent[cur]);
    }

    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        vector<int>parent(n);
        iota(parent.begin(), parent.end(),0);
        for(int i = 0; i < n; ++i){
            for(int j = i + 1; j < n; ++j){
                if(graph[i][j])
                {
                    parent[find(parent, i)] = parent[find(parent, j)];
                }
            }
        }
    
        int res = *min_element(initial.begin(), initial.end());
        vector<int>initial_cnt(n);
        vector<int>cnt(n);

        for(auto & ini: initial)
            ++initial_cnt[find(parent, ini)];
        //initial_cnt 是initial 是否形成cycle,

        for(int i = 0; i<n; ++i)
            ++cnt[find(parent, i)];
        //cnt 是发现每个cycle 中有几个count,

        int max_count = cnt[res];
        for(auto & ini: initial){
            int p = find(parent, ini);
            if(initial_cnt[p] == 1 && (cnt[p] > max_count || cnt[p] == max_count && ini < res)){
                //如果一样的count 找最小的i
                max_count = cnt[p];
                res = ini;
            }
        }
        return res;
    }
};